<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collapsible Dendrogram with Value Bars</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .node {
            cursor: pointer;
        }
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 8px;
        }
        .node text {
            font: 18px sans-serif; /* Original font size */
            pointer-events: none; /* Prevent mouse events on text */
        }
        .value-text {
            font: 46px sans-serif; /* Increased font size for value text */
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 3px;
        }
        .bar {
            fill: red;
        }
    </style>
</head>
<body>
    <svg width="1200" height="800"></svg> <!-- SVG size -->
    <script>
        const url = 'https://github.com/joy-ald/City/blob/main/buildings_hierarchy_d3.json'; // Your JSON URL

        d3.json(url).then(data => {
            const rootData = data.city; // Access the 'city' object
            const root = d3.hierarchy(rootData, d => d.children);
            root.descendants().forEach(d => {
                d._children = d.children; // Store the original children
                if (d.children) d.children = null; // Start with children collapsed
            });

            const svg = d3.select("svg"),
                width = +svg.attr("width"),
                height = +svg.attr("height");

            const g = svg.append("g").attr("transform", "translate(40,0)");

            const tree = d3.tree().size([height - 30, width - 500]);

            // Render the tree
            update(root);

            // Click event to toggle children
            function click(event, d) {
                if (d.children) {
                    d.children = null; // Collapse the node
                } else {
                    d.children = d._children; // Expand the node
                }
                update(root); // Update the tree after toggling
            }

            // Update function to render the tree
            function update(source) {
                const nodes = root.descendants(),
                    links = root.links();

                tree(root);
                
                // Update nodes
                const node = g.selectAll(".node")
                    .data(nodes, d => d.data.zip_code || d.data.building_type); // Unique key

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf"))
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .on("click", click); // Add click event

                nodeEnter.append("circle").attr("r", 10);
                
                // Add text with wrapping
                nodeEnter.append("text")
                    .attr("dy", d => d.children ? -15 : 30)
                    .attr("x", d => d.children ? -12 : -20)
                    .style("text-anchor", d => d.children ? "end" : "start")
                    .text(d => {
                        if (d.data.zip_code !== undefined) {
                            return `Zip: ${d.data.zip_code}`;
                        } else if (d.data.building_type) {
                            return `${d.data.building_type}`;
                        }
                        return d.data.parent || ""; // Default case
                    })
                    .call(wrap, 350); // Wrap text to fit

                // Add value text separately with increased font size and dollar sign
                nodeEnter.append("text")
                    .attr("class", "value-text")
                    .attr("dy", 5) // Position below the main text (adjusted)
                    .attr("x", d => d.children ? -12 : 30)
                    .style("text-anchor", d => d.children ? "end" : "start")
                    .text(d => {
                        if (d.data.building_type) {
                            return `Value: $${d.data.value}`; // Add dollar sign
                        }
                        return ""; // Only display value for building types
                    });

                // Transition nodes to their new position
                nodeEnter.merge(node)
                    .transition()
                    .duration(750)
                    .attr("transform", d => `translate(${d.y},${d.x})`);

                // Remove old nodes
                node.exit().remove();

                // Update links
                const link = g.selectAll(".link")
                    .data(links, d => d.target.data.zip_code || d.target.data.building_type);

                link.enter().append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x))
                    .merge(link)
                    .transition()
                    .duration(750)
                    .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x));

                link.exit().remove();

                // Draw value bars for the last level nodes
                const barWidth = 500; // Max width for bars
                const valueNodes = nodes.filter(n => n.data.building_type);
                const maxValue = d3.max(valueNodes, d => d.data.value) || 1; // Avoid divide by zero

                const bars = g.selectAll(".bar")
                    .data(valueNodes, d => d.data.building_type); // Only get building type nodes

                // Position bars below the text on the extreme right side of the SVG
                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", width - 200) // Initial position, will update in the merge
                    .attr("y", d => d.x + 15) // Position below the value text
                    .attr("width", d => (d.data.value / maxValue) * barWidth) // Scale bar width
                    .attr("height", 10) // Bar height
                    .merge(bars)
                    .transition()
                    .duration(750)
                    .attr("y", d => d.x + 30) // Maintain position after transition
                    .attr("x", (d, i, nodes) => {
                        const textWidth = d3.select(nodes[i]).select("text").node().getComputedTextLength();
                        return width - 250 + 10 ; // Add gap between text and bar
                    }) // Update x position based on text width
                    .attr("width", d => (d.data.value / maxValue) * barWidth); // Update width for transitions

                bars.exit().remove();
            }

            // Function to wrap text
            function wrap(text, width) {
                text.each(function () {
                    const textElement = d3.select(this);
                    const words = textElement.text().split(/\s+/).reverse();
                    let word,
                        line = [],
                        lineHeight = 1.1, // ems
                        x = textElement.attr("x"),
                        y = textElement.attr("y"),
                        tspan = textElement.text(null).append("tspan").attr("x", x).attr("y", y);

                    while (word = words.pop()) {
                        line.push(word);
                        tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop();
                            tspan.text(line.join(" "));
                            line = [word];
                            tspan = textElement.append("tspan").attr("x", x).attr("y", y).attr("dy", `${lineHeight}em`).text(word);
                        }
                    }
                });
            }
        });
    </script>
</body>
</html>
