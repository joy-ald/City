<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Dendrogram with Bars</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .node {
            cursor: pointer;
        }
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 3px;
        }
        .node text {
            font: 12px sans-serif;
            pointer-events: none;
            white-space: pre-wrap; /* Enable text wrapping */
        }
        .value-text {
            font: bold 14px sans-serif; /* Adjusted font size */
            fill: white; /* White text color for visibility */
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
        .bar {
            fill: red;
        }
        .tooltip {
            position: absolute;
            background: lightgrey;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 5px;
            visibility: hidden;
        }
        .legend {
            font: 12px sans-serif;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <svg width="800" height="600"></svg> <!-- SVG size -->
    <div class="tooltip"></div> <!-- Tooltip for value display -->
    <script>
        const url = 'https://raw.githubusercontent.com/joy-ald/City/refs/heads/main/buildings_hierarchy_d3.json'; // Your JSON URL

        d3.json(url).then(data => {
            const rootData = data.city; // Access the 'city' object
            const root = d3.hierarchy(rootData, d => d.children);
            root.descendants().forEach(d => {
                d._children = d.children; // Store the original children
                if (d.children) d.children = null; // Start with children collapsed
            });

            const svg = d3.select("svg"),
                width = +svg.attr("width"),
                height = +svg.attr("height"),
                radius = Math.min(width, height) / 2 - 40; // Radius for the circular layout

            const g = svg.append("g").attr("transform", `translate(${width / 2}, ${height / 2})`); // Center of the SVG

            const tree = d3.tree()
                .size([2 * Math.PI, radius])
                .separation((a, b) => (a.parent == b.parent ? 1 : 1.5)); // Control spacing

            update(root);

            function click(event, d) {
                if (d.children) {
                    d.children = null; // Collapse the node
                } else {
                    d.children = d._children; // Expand the node
                }
                update(root); // Update the tree after toggling
            }

            function update(source) {
                const nodes = root.descendants(),
                    links = root.links();

                tree(root);

                // Position nodes in polar coordinates
                nodes.forEach(d => {
                    d.x = d.x; // Angle in radians
                    d.y = d.y; // Radius
                });

                const node = g.selectAll(".node")
                    .data(nodes, d => d.data.zip_code || d.data.building_type); // Unique key

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf"))
                    .attr("transform", d => `rotate(${(d.x * 180 / Math.PI) - 90}) translate(${d.y}, 0)`) // Polar to Cartesian conversion
                    .on("click", click); // Add click event

                const nodeDiameter = d => d.depth === 0 ? 10 : (10 / Math.pow(2, d.depth)); // Reduce size for child nodes
                nodeEnter.append("circle").attr("r", d => nodeDiameter(d));

                nodeEnter.append("text")
                    .attr("dy", 23) // Moved down by 20 units
                    .attr("x", d => d.children ? -32 : 32) // Moved left/right based on child status
                    .style("text-anchor", d => d.children ? "end" : "start")
                    .text(d => {
                        if (d.data.zip_code !== undefined) {
                            return `Zip: ${d.data.zip_code}`;
                        } else if (d.data.building_type) {
                            const buildingTypeMap = {
                                "Building Residential - New": "ResN",
                                "Building Commercial - New": "ComN",
                                "Building Commercial - Rehab": "ComR"
                                // Add other mappings as needed
                            };
                            return buildingTypeMap[d.data.building_type] || d.data.building_type;
                        }
                        return d.data.parent || ""; // Default case
                    });

                nodeEnter.merge(node)
                    .transition()
                    .duration(750)
                    .attr("transform", d => `rotate(${(d.x * 180 / Math.PI) - 90}) translate(${d.y}, 0)`);

                node.exit().remove();

                const link = g.selectAll(".link")
                    .data(links, d => d.target.data.zip_code || d.target.data.building_type);

                link.enter().append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkRadial()
                        .angle(d => d.x)
                        .radius(d => d.y))
                    .merge(link)
                    .transition()
                    .duration(750)
                    .attr("d", d3.linkRadial()
                        .angle(d => d.x)
                        .radius(d => d.y));

                link.exit().remove();

                const valueNodes = nodes.filter(n => n.data.building_type);
                const maxValue = d3.max(valueNodes, d => d.data.value) || 1; // Avoid divide by zero
                const barWidth = 200; // Max width for bars

                const bars = g.selectAll(".bar")
                    .data(valueNodes, d => d.data.building_type);

                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => (width / 2) + 10) // Position on the right side
                    .attr("y", d => -d.x + 60) // Position based on node position
                    .attr("width", d => Math.min((d.data.value / maxValue) * barWidth, width - 240)) // Scale bar width
                    .attr("height", 10)
                    .on("mouseover", function(event, d) {
                        d3.select(this).style("fill", "orange"); // Change color on hover
                        d3.select(".tooltip").style("visibility", "visible").text(`$${d.data.value}`); // Show tooltip with value
                    })
                    .on("mousemove", function(event) {
                        d3.select(".tooltip")
                            .style("top", (event.pageY - 10) + "px")
                            .style("left", (event.pageX + 10) + "px"); // Move tooltip with mouse
                    })
                    .on("mouseout", function() {
                        d3.select(this).style("fill", "red"); // Reset color
                        d3.select(".tooltip").style("visibility", "hidden"); // Hide tooltip
                    })
                    .merge(bars)
                    .transition()
                    .duration(750)
                    .attr("y", d => -d.x + 60) // Maintain position after transition
                    .attr("width", d => Math.min((d.data.value / maxValue) * barWidth, width - 240)); // Update width for transitions

                bars.exit().remove();

                // Add value text inside the bars
                const valueText = g.selectAll(".value-text")
                    .data(valueNodes, d => d.data.building_type);

                valueText.enter().append("text")
                    .attr("class", "value-text")
                    .attr("x", d => (width / 2) + ((d.data.value / maxValue) * barWidth) + 10) // Position slightly inside the bar
                    .attr("y", d => -d.x + 67) // Position slightly above the bar
                    .attr("dy", ".35em")
                    .attr("text-anchor", "start")
                    .merge(valueText)
                    .transition()
                    .duration(750)
                    .attr("x", d => (width / 2) + ((d.data.value / maxValue) * barWidth) + 10) // Update position based on bar position
                    .attr("y", d => -d.x + 67) // Keep above the bar
                    .text(d => `$${d.data.value}`); // Show value with dollar sign

                valueText.exit().remove();

                // Add legend for four-letter keys
                const legendData = [
                    { key: "ResN", label: "Residential - New" },
                    { key: "ComN", label: "Commercial - New" },
                    { key: "ComR", label: "Commercial - Rehab" }
                ];

                const legend = g.append("g")
                    .attr("transform", `translate(-${width / 2 - 20}, ${height / 2 - 40})`);

                legend.selectAll(".legend-item")
                    .data(legendData)
                    .enter().append("text")
                    .attr("class", "legend-item")
                    .attr("x", 0)
                    .attr("y", (d, i) => i * 15)
                    .text(d => `${d.key}: ${d.label}`);
            }
        });
    </script>
</body>
</html>
